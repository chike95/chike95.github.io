import{_ as a,c as i,o as t,a4 as l}from"./chunks/framework.4aTu-Nia.js";const s="/assets/image-1.CV4tMb5O.png",e="/assets/image-2.IQ4xfDes.png",r="/assets/image-5.l3M30fce.png",n="/assets/image-3.BdnMnNRo.png",p="/assets/cb743224f421ea67a8ac50e8c908263.CipEzbNA.png",o="/assets/image-4.D4lBSNeR.png",h="/assets/image-6.C2MsZ_SI.png",c="/assets/image-7.C5NtSSae.png",d="/assets/image-8.C0Wf54lw.png",u="/assets/image-9.D4Lu_lOq.png",k="/assets/image-12.CEuyPNF_.png",b="/assets/image-10.vzZdLg0D.png",m="/assets/image-11.ClnYesgp.png",F=JSON.parse('{"title":"串行通信协议","description":"","frontmatter":{},"headers":[],"relativePath":"iot/communication/data.md","filePath":"iot/communication/data.md"}'),g={name:"iot/communication/data.md"},S=l('<h1 id="串行通信协议" tabindex="-1">串行通信协议 <a class="header-anchor" href="#串行通信协议" aria-label="Permalink to &quot;串行通信协议&quot;">​</a></h1><p>串行通信协议是让计算机和其他设备之间进行数据交换的一种标准。通过这些协议，设备可以按照预定的格式和速率发送和接收数据。</p><h2 id="rs232" tabindex="-1">RS232 <a class="header-anchor" href="#rs232" aria-label="Permalink to &quot;RS232&quot;">​</a></h2><h2 id="rs485" tabindex="-1">RS485 <a class="header-anchor" href="#rs485" aria-label="Permalink to &quot;RS485&quot;">​</a></h2><p>RS-485 是一个物理层标准，定义了电气特性和信号传输方式；要实现实际的数据通信，还需要在其上构建适合具体应用的高层协议（如 modbus、BACnet 等），这些协议定义了数据包的结构、地址格式、错误检测和纠正机制等。</p><p>基本概念</p><p>（1）差分信号：</p><p>RS-485 使用差分信号传输数据，这意味着信号通过两条线（A 和 B）传输，电压差决定了逻辑状态。这种方式比单端信号抗干扰能力更强。</p><p>（2）多点通信：</p><p>RS-485 支持多达 32 个设备在同一总线上进行通信，允许多个发送器和接收器共享同一个双绞线对。</p><p><img src="'+s+'" alt="alt text" data-fancybox="gallery"></p><p>（3）全双工和半双工模式：</p><p>RS-485 可以工作在全双工（使用四根线，两对进行独立的发送和接收）和半双工（使用两根线，同一对进行发送和接收）的模式。</p><h3 id="物理层特性" tabindex="-1">物理层特性 <a class="header-anchor" href="#物理层特性" aria-label="Permalink to &quot;物理层特性&quot;">​</a></h3><p>传输线：通常使用带屏蔽的双绞线电缆，推荐使用 120 欧姆的终端电阻来匹配电缆阻抗，防止信号反射。</p><p>连接器：常见的 RS-485 连接器类型包括 DB-9、DB-25 和 5 针插头等。</p><h3 id="电气特性" tabindex="-1">电气特性 <a class="header-anchor" href="#电气特性" aria-label="Permalink to &quot;电气特性&quot;">​</a></h3><p>电压范围：RS-485 的差分电压范围为+12V 到-7V，保证在长距离传输时仍能保持可靠的信号质量。</p><p>传输距离：在较低波特率下（如 9600 bps），RS-485 可以传输超过 1200 米（4000 英尺）。但随着波特率增加，传输距离会减少。</p><p>波特率：典型的波特率范围从几百 bps 到 10Mbps，但实际应用中常见的波特率为 9600 bps 到 115200 bps。</p><h3 id="连接方式" tabindex="-1">连接方式 <a class="header-anchor" href="#连接方式" aria-label="Permalink to &quot;连接方式&quot;">​</a></h3><p>总线型结构：RS-485 采用总线型拓扑结构，所有设备并联在一条主线上。</p><ul><li>图中红色线为 485 总线(一个协议转换器只能引出一条总线)</li><li>绿线为测点线</li></ul><p><img src="'+e+'" alt="alt text" data-fancybox="gallery"></p><p><img src="'+r+'" alt="alt text" data-fancybox="gallery"></p><ul><li>错误示范：星形连接</li><li>正确做法：手拉手连接</li></ul><p><img src="'+n+'" alt="alt text" data-fancybox="gallery"></p><h3 id="常见问题及解决方案" tabindex="-1">常见问题及解决方案 <a class="header-anchor" href="#常见问题及解决方案" aria-label="Permalink to &quot;常见问题及解决方案&quot;">​</a></h3><p>（1）接线错误：检查 AB 线是否接反，线路是否断开</p><p>（2）波特率错误：检查设备是否使用正确的波特率，或检查连接器是否正确连接</p><p>（3）地址冲突：确保每个设备的地址都是唯一的，避免重复使用。</p><p>（4）电压过低或过高：检查连接器、电缆和终端电阻的连接是否正确，并确保设备在正确的电压范围内工作。</p><p>（5）信号丢失或损坏：检查连接器、电缆和终端电阻的连接是否正确，并确保设备在正确的电压范围内工作。</p><p><img src="'+p+'" alt="alt text" data-fancybox="gallery"></p><p>（6）信号反射：使用 120 欧 终端电阻来匹配传输线的阻抗。</p><p><img src="'+o+'" alt="alt text" data-fancybox="gallery"></p><p><img src="'+h+`" alt="alt text" data-fancybox="gallery"></p><p>（7）噪声干扰：使用屏蔽双绞线电缆，并确保良好的接地。</p><p>（8）总线冲突：在多主设备系统中，使用仲裁机制或协议来避免冲突。</p><h2 id="uart" tabindex="-1">UART <a class="header-anchor" href="#uart" aria-label="Permalink to &quot;UART&quot;">​</a></h2><p>UART（Universal Asynchronous Receive Transmitter，通用异步收发传输器）：也就是我们经常所说的串口，基本都用于调试。</p><div class="warning custom-block"><p class="custom-block-title">注意</p><ul><li><p>A 和 B 通信 A.TX 要接 B.RX，A.RX 要接 B.TX（A 用 TX 发 B 当然要用 RX 来收了！）</p></li><li><p>主机和从机至少要接三根线，RX、TX 和 GND。TX 用于发送数据，RX 用于接受数据（收发不是一根线，所以是全双工方式）。</p></li></ul></div><p>如果 A 是 PC 机，B 是单片机，A 和 B 之间还要接一块电平转换芯片，用于将 TTL/CMOS（单片机电平）转换为 RS232（PC 机电平）。因为 TTL/CMOS 电平范围是 0~1.8/2.5/3.3/5V(不同单片机范围不同)，高电压表示 1，低电压表示 0。而 RS232 逻辑电平范围-12V~12V，-5~-12 表示高电平，+5~+12V 表示低电平。</p><h3 id="原理及特征" tabindex="-1">原理及特征 <a class="header-anchor" href="#原理及特征" aria-label="Permalink to &quot;原理及特征&quot;">​</a></h3><h4 id="异步通信" tabindex="-1">异步通信 <a class="header-anchor" href="#异步通信" aria-label="Permalink to &quot;异步通信&quot;">​</a></h4><p>UART 是异步通信的一种形式，即发送和接收端设备之间不共享时钟信号。相反，每个数据帧的开始和结束由起始位和停止位标识。</p><h4 id="数据帧结构" tabindex="-1">数据帧结构 <a class="header-anchor" href="#数据帧结构" aria-label="Permalink to &quot;数据帧结构&quot;">​</a></h4><div class="info custom-block"><p class="custom-block-title">UART 数据帧组成</p><ul><li>起始位（Start Bit）：始终为逻辑低电平（0），表示数据帧的开始。</li><li>数据位（Data Bits）：可以是 5、6、7 或 8 位，代表要传输的实际数据。</li><li>可选的校验位（Parity Bit）：用于错误检测，可以是奇校验、偶校验或无校验。校验位根据数据位的奇偶性来确定其值。</li><li>停止位（Stop Bit）：一个或多个逻辑高电平（1），用于表示数据帧的结束。</li></ul></div><p>以下是 UART 数据帧的常见结构：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">起始位</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  数据位</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  可选的校验位</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  停止位</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">---------------------------------</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   |</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      |</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">         |</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     |</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ST</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> D0-D7</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   P</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  SP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">---------------------------------</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">注意</p><p>UART 串口通信每次只能发一个字节</p></div><h4 id="传输流程" tabindex="-1">传输流程 <a class="header-anchor" href="#传输流程" aria-label="Permalink to &quot;传输流程&quot;">​</a></h4><ul><li>发送端：将数据按照设置的数据位数和校验位进行编码，并在每个数据帧前加上起始位和结尾处加上停止位。</li><li>接收端：侦听传输线上的数据，根据波特率同步时钟，解码数据位、校验位和停止位，以恢复发送的原始数据。</li></ul><h4 id="波特率" tabindex="-1">波特率 <a class="header-anchor" href="#波特率" aria-label="Permalink to &quot;波特率&quot;">​</a></h4><p>UART 的通信速率由波特率（Baud Rate）定义，波特率是指每秒传输的符号（比特）数。常见的波特率包括 9600、19200、115200 等。发送和接收双方必须以相同的波特率进行配置，以确保数据的正确传输。</p><div class="info custom-block"><p class="custom-block-title">波特率计算公式</p><p>波特率 = 发送频率 / 波特率分频系数</p><p>9600 波特率指的是每秒可以传输 9600 个二进制位，也就是 9600/8 个英文字母的数据量，也就是 1200 个字节，大约 1.2KB。</p><p><img src="`+c+'" alt="alt text" data-fancybox="gallery"></p></div><h2 id="iic" tabindex="-1">IIC <a class="header-anchor" href="#iic" aria-label="Permalink to &quot;IIC&quot;">​</a></h2><p>I²C（Inter-Integrated Circuit，也称为 I2C 或 IIC,译作集成电路总线）是一种常见的串行通信协议，用于在微控制器和外围设备之间进行低速、短距离的数据传输。</p><h3 id="物理层" tabindex="-1">物理层 <a class="header-anchor" href="#物理层" aria-label="Permalink to &quot;物理层&quot;">​</a></h3><p>I2C 是多主从架构，每个设备都有唯一的地址，一个主设备理论上可以接 127 个从设备，设备的 SDA 并接在一起，SCl 并接在一起。</p><p><img src="'+d+'" alt="alt text" data-fancybox="gallery"></p><p>I2C 总线内部都是采用漏极开路驱动，示意图如图，栅极给电压时 mos 导通，输出低电平，栅极给 0 时 mos 关断输出呈高阻态，那么这里就无法输出高电平。</p><p><img src="'+u+'" alt="alt text" data-fancybox="gallery"></p><p>加上上拉电阻后（一般在 4.7k~10k）可以实现高低电平的输出：开关断开时电阻趋于无穷，电流为 0，电源电压为输出电压，即输出高电平；开关闭合，输出低电平。只要有一个设备拉低总线电平，总线的电平就会被拉低，这就是线与功能，便于数据的传输和仲裁。</p><p><img src="'+k+'" alt="alt text" data-fancybox="gallery"></p><p><img src="'+b+'" alt="alt text" data-fancybox="gallery"></p><h4 id="主从模式" tabindex="-1">主从模式 <a class="header-anchor" href="#主从模式" aria-label="Permalink to &quot;主从模式&quot;">​</a></h4><ul><li>主设备（Master）：主设备发起通信，生成时钟信号，并负责发送起始条件和停止条件。</li><li>从设备（Slave）：从设备响应主设备的请求，进行数据接收或发送。</li></ul><div class="warning custom-block"><p class="custom-block-title">注意</p><p>多主机会产生总线裁决问题。当多个主机同时想占用总线时，企图启动总线传输数据，就叫做总线竞争。I2C 通过总线仲裁，以决定哪台主机控制总线</p></div><h4 id="双线通信" tabindex="-1">双线通信 <a class="header-anchor" href="#双线通信" aria-label="Permalink to &quot;双线通信&quot;">​</a></h4><ul><li>SCL（Serial Clock Line）：时钟信号线，由主设备生成，用于同步数据传输。</li><li>SDA（Serial Data Line）：数据线，用于在设备之间传输数据。SCL 和 SDA 都是开漏（Open-Drain）驱动，需要上拉电阻。</li></ul><h3 id="协议层" tabindex="-1">协议层 <a class="header-anchor" href="#协议层" aria-label="Permalink to &quot;协议层&quot;">​</a></h3><h4 id="数据帧结构-1" tabindex="-1">数据帧结构 <a class="header-anchor" href="#数据帧结构-1" aria-label="Permalink to &quot;数据帧结构&quot;">​</a></h4><p>I2C 数据的传输也遵循一定的格式。它有开始和停止条件，中间进行 8bit 的数据传输，没有奇偶校验，并且在一个开始条件和停止条件可之间可以传要多少数据有多少数据。提醒一下，我们的总线默认保持高电平。</p><p><img src="'+m+'" alt="alt text" data-fancybox="gallery"></p><ul><li>开始条件：在时钟线保持高电平时，数据线从高电平转为低电平，即检测到一个下降沿，会形成一个开始条件；</li><li>停止条件：时钟保持高电平时，数据线从低电平转为高电平形成一个停止条件。</li><li>进行数据传输前也就是紧跟开始条件后，我们要传送地址字节，前 7 位是从设备地址（这也是为什么一个主机理论上最多能接 127 个从机，2^7-1），第八位是读/写标志位。每 8bit 传输- 完成，第九位是应答位。如果是主设备发送数据，就是从设备应答，如果是主设备读取数据，就是主设备应答。</li></ul><h4 id="寄存器" tabindex="-1">寄存器 <a class="header-anchor" href="#寄存器" aria-label="Permalink to &quot;寄存器&quot;">​</a></h4><p>控制寄存器控制开始停止条件，每传输完一个字节会进入内部中断，状态寄存器记录单片机的工作状态。作为主机时，分频器寄存器配合内部时钟设置 I2C 的波特率；地址寄存器是从机地址编址；最后是数据寄存器。</p><h2 id="spi" tabindex="-1">SPI <a class="header-anchor" href="#spi" aria-label="Permalink to &quot;SPI&quot;">​</a></h2><p>参考链接：<a href="https://blog.csdn.net/handy34/article/details/137791972" target="_blank" rel="noreferrer">https://blog.csdn.net/handy34/article/details/137791972</a></p><p>SPI（Serial Peripheral Interface，串行外设接口）是由摩托罗拉公司开发的一种全双工、同步的串行通信协议，用于在微控制器、嵌入式系统和外部设备之间进行数据传输。SPI 被广泛应用于数字集成电路之间的通信，特别适用于连接多个外设。该总线大量用在与 EEPROM、ADC、FRAM 和显示驱动器之类的慢速外设器件通信。</p><h3 id="总线结构" tabindex="-1">总线结构 <a class="header-anchor" href="#总线结构" aria-label="Permalink to &quot;总线结构&quot;">​</a></h3><h4 id="主从模式-1" tabindex="-1">主从模式 <a class="header-anchor" href="#主从模式-1" aria-label="Permalink to &quot;主从模式&quot;">​</a></h4><p>SPI 通信中存在一个主设备（Master）和一个或多个从设备（Slave）。主设备负责控制通信时序，并发起数据传输；从设备则被动地响应主设备的命令并进行数据传输。</p><h4 id="信号线" tabindex="-1">信号线 <a class="header-anchor" href="#信号线" aria-label="Permalink to &quot;信号线&quot;">​</a></h4><div class="info custom-block"><p class="custom-block-title">SPI 信号线</p><ul><li>SCLK（Serial Clock）：主设备生成的时钟信号，用于同步数据传输。</li><li>MOSI（Master Output Slave Input）：主设备输出的数据信号，传输给从设备。</li><li>MISO（Master Input Slave Output）：从设备输出的数据信号，传输给主设备。</li><li>SS（Slave Select）：主设备使用该信号选择要与之通信的从设备。</li></ul></div><h4 id="数据传输" tabindex="-1">数据传输 <a class="header-anchor" href="#数据传输" aria-label="Permalink to &quot;数据传输&quot;">​</a></h4><p>SPI 使用全双工传输方式，也就是可以同时进行数据的发送和接收。主设备通过 MOSI 发送数据到从设备的 MISO，同时从设备也可以通过 MISO 发送数据给主设备。</p><h4 id="时序特点" tabindex="-1">时序特点 <a class="header-anchor" href="#时序特点" aria-label="Permalink to &quot;时序特点&quot;">​</a></h4><p>SPI 采用的是同步时钟，数据传输时钟极性和相位可以通过配置进行调整。</p><h3 id="数据传输流程" tabindex="-1">数据传输流程 <a class="header-anchor" href="#数据传输流程" aria-label="Permalink to &quot;数据传输流程&quot;">​</a></h3><ul><li>主设备选择要与之通信的从设备，通过拉低相应的 SS 信号将其选为活动设备。</li><li>主设备通过 SCLK 产生时钟信号，确定数据传输的时序。</li><li>主设备向 MOSI 发送数据，从设备通过 MISO 接收数据。</li><li>主设备和从设备在每个时钟周期中交换一个完整的数据位。数据位的传输顺序可以由主设备或从设备决定。</li><li>数据传输完成后，主设备通过拉高 SS 信号将从设备取消选中。</li></ul><h2 id="usb" tabindex="-1">USB <a class="header-anchor" href="#usb" aria-label="Permalink to &quot;USB&quot;">​</a></h2><h2 id="can" tabindex="-1">CAN <a class="header-anchor" href="#can" aria-label="Permalink to &quot;CAN&quot;">​</a></h2>',94),f=[S];function q(x,_,y,P,C,A){return t(),i("div",null,f)}const R=a(g,[["render",q]]);export{F as __pageData,R as default};
